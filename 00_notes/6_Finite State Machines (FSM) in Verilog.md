# üìò Finite State Machines (FSM)

* **Subject:** Digital Design / Verilog HDL
* **Topic:** Sequential Control Logic

---

## 1. Definition of FSM

A **Finite State Machine (FSM)** is a mathematical and logical model used to describe the behavior of a synchronous sequential circuit that operates in a finite number of states.

An FSM changes its state based on:

* Current state
* Input conditions
* Clock signal

FSMs provide a structured and predictable way to design control systems.

---

## 2. Components of an FSM

An FSM consists of the following elements:

### 2.1 Finite States

Distinct operating modes of the system.
Each state represents a specific behavior.

**Example:**
`IDLE, LOAD, SHIFT, DONE`

---

### 2.2 State Transitions

Rules that define how the FSM moves from one state to another depending on inputs and conditions.

**Example:**
If input = 1 ‚Üí move from `IDLE` to `START`

---

### 2.3 State Diagram

Graphical representation showing:

* States as circles
* Transitions as arrows
* Conditions on arrows

Used for design and verification.

---

### 2.4 Inputs

External signals that influence state transitions.

**Examples:**

* Button
* Sensor
* Serial data
* Control signal

---

### 2.5 Outputs

Signals generated by the FSM that control external hardware.

**Examples:**

* Enable
* Load
* Done
* Error

---

## 3. Types of FSM

FSMs are classified based on how outputs are generated.

---

### 3.1 Mealy Machine

In a Mealy FSM, the output depends on:

* Present state
* Present input

Output can change immediately when input changes.

**Characteristics:**

* Fewer states
* Faster response
* Output may glitch
* Timing critical

**Mathematical form:**
`Output = f(state, input)`

---

### 3.2 Moore Machine

In a Moore FSM, the output depends only on:

* Present state

Output changes only on clock edge.

**Characteristics:**

* More states
* Slower response
* Stable output
* Safer for hardware

**Mathematical form:**
`Output = f(state)`

---

## 4. Comparison: Mealy vs Moore

| Feature                | Mealy FSM     | Moore FSM  |
| ---------------------- | ------------- | ---------- |
| Output depends on      | State + Input | Only State |
| Output change          | Immediate     | On clock   |
| Speed                  | Faster        | Slower     |
| Glitch risk            | High          | Low        |
| States required        | Fewer         | More       |
| Design complexity      | Higher        | Lower      |
| Preferred for hardware | Less          | More       |

---

## 5. State Encoding Techniques

### 5.1 Binary Encoding

States are encoded using binary numbers.

**Example:**

```
IDLE = 2‚Äôb00  
S1   = 2‚Äôb01  
S2   = 2‚Äôb10  
S3   = 2‚Äôb11  
```

‚úî Uses fewer flip-flops
‚ùå Complex combinational logic

---

### 5.2 One-Hot Encoding

Each state uses one flip-flop.

**Example:**

```
IDLE = 4‚Äôb0001  
S1   = 4‚Äôb0010  
S2   = 4‚Äôb0100  
S3   = 4‚Äôb1000  
```

‚úî Fast
‚úî Simple logic
‚ùå More hardware

---

## 6. Recommended FSM Coding Style (Two-Always Block)

### Block 1: State Register (Sequential)

* Stores present state
* Triggered on clock
* Uses non-blocking assignment

```verilog
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end
```

---

### Block 2: Next State Logic (Combinational)

* Determines next state
* Uses blocking assignment
* Must include default

```verilog
always @(*) begin
    next_state = IDLE;
    case (state)
        IDLE: if (in) next_state = S1;
        S1  : if (!in) next_state = S2;
        default: next_state = IDLE;
    endcase
end
```

---

## 7. Output Logic Methods

### Method 1: Inside combinational block

```verilog
always @(*) begin
    out = 0;
    case (state)
        S2: out = 1;
    endcase
end
```

---

### Method 2: Continuous assignment

```verilog
assign out = (state == DONE);
```

---

### Method 3: Registered output (Best Practice)

```verilog
always @(posedge clk) begin
    out <= (state == DONE);
end
```

‚úî Removes glitches
‚úî Better timing

---

## 8. Example: Moore FSM ‚Äì Sequence Detector (1011)

**States:**
`IDLE ‚Üí S1 ‚Üí S10 ‚Üí S101 ‚Üí S1011`

**Output = 1 when in `S1011`**

```verilog
module seq_1011 (
    input clk, rst, in,
    output reg out
);

    typedef enum reg [2:0] {
        IDLE  = 3'b000,
        S1    = 3'b001,
        S10   = 3'b010,
        S101  = 3'b011,
        S1011 = 3'b100
    } state_t;

    state_t state, next_state;

    // State register
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = IDLE;
        case (state)
            IDLE : if (in) next_state = S1;
            S1   : if (!in) next_state = S10;
            S10  : if (in) next_state = S101;
            S101 : if (in) next_state = S1011;
            S1011: next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(*) begin
        out = (state == S1011);
    end

endmodule
```

---

## 9. Hardware View of FSM

FSM synthesizes into:

* Flip-flops ‚Üí store state
* Combinational logic ‚Üí compute next state
* Optional registers ‚Üí outputs

FSM acts as **controller**
Datapath acts as **worker**

---

## 10. Common Design Mistakes

‚ùå No default state
‚ùå Blocking assignment in sequential block
‚ùå Missing reset
‚ùå Missing default case
‚ùå Mixing logic
‚ùå No testbench
‚ùå Unhandled illegal states

---

## 11. Testbench Strategy

Testbench should:

* Generate clock
* Apply reset
* Change inputs
* Observe output

```verilog
always 5 clk = ~clk;

initial begin
    rst = 1; in = 0;
    10 rst = 0;

    in = 1; 10;
    in = 0; 10;
    in = 1; 10;
    in = 1; 10;

    $finish;
end
```

---

## 12. Applications of FSM

* Traffic light controller
* Sequence detector
* Elevator controller
* CPU control unit
* UART controller
* Washing machine
* Protocol handler

---

## Summary

Finite State Machines:

* Model sequential behavior
* Provide structure
* Improve reliability
* Simplify control logic

In Verilog:

* Use two always blocks
* Use correct assignments
* Always reset
* Always define defaults

**FSM = Backbone of control logic**

---

