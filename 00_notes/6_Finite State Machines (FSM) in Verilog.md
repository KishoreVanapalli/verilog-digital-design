Study Notes: Finite State Machines (FSM)

Subject: Digital Design / Verilog HDL
Topic: Sequential Control Logic
Last Updated: 2026

---

 1. Definition of FSM

A Finite State Machine (FSM) is a mathematical and logical model used to describe the behavior of a synchronous sequential circuit that operates in a finite number of states.
An FSM changes its state based on:

 Current state
 Input conditions
 Clock signal

FSMs provide a structured and predictable way to design control systems.

---

 2. Components of an FSM

An FSM consists of the following elements:

 2.1 Finite States

Distinct operating modes of the system.
Each state represents a specific behavior.

Example:
IDLE, LOAD, SHIFT, DONE

---

 2.2 State Transitions

Rules that define how the FSM moves from one state to another depending on inputs and conditions.

Example:
If input = 1 → move from IDLE to START

---

 2.3 State Diagram

Graphical representation showing:

 States as circles
 Transitions as arrows
 Conditions on arrows

Used for design and verification.

---

 2.4 Inputs

External signals that influence state transitions.
Examples:

 Button
 Sensor
 Serial data
 Control signal

---

 2.5 Outputs

Signals generated by the FSM that control external hardware.
Examples:

 Enable
 Load
 Done
 Error

---

 3. Types of FSM

FSMs are classified based on how outputs are generated.

---

 3.1 Mealy Machine

In a Mealy FSM, the output depends on:

 Present state
 Present input

Output can change immediately when input changes.

 Characteristics:

 Fewer states
 Faster response
 Output may glitch
 Timing critical

 Mathematical form:

Output = f(state, input)

---

 3.2 Moore Machine

In a Moore FSM, the output depends only on:

 Present state

Output changes only on clock edge.

 Characteristics:

 More states
 Slower response
 Stable output
 Safer for hardware

 Mathematical form:

Output = f(state)

---

 4. Comparison: Mealy vs Moore

| Feature                | Mealy FSM     | Moore FSM  |
| ---------------------- | ------------- | ---------- |
| Output depends on      | State + Input | Only State |
| Output change          | Immediate     | On clock   |
| Speed                  | Faster        | Slower     |
| Glitch risk            | High          | Low        |
| States required        | Fewer         | More       |
| Design complexity      | Higher        | Lower      |
| Preferred for hardware | Less          | More       |

---

 5. State Encoding Techniques

 5.1 Binary Encoding

States are encoded using binary numbers.

Example:
IDLE = 2’b00
S1   = 2’b01
S2   = 2’b10
S3   = 2’b11

✔ Uses fewer flip-flops
❌ Complex combinational logic

---

 5.2 One-Hot Encoding

Each state uses one flip-flop.

Example:
IDLE = 4’b0001
S1   = 4’b0010
S2   = 4’b0100
S3   = 4’b1000

✔ Fast
✔ Simple logic
❌ More hardware

---

 6. Recommended FSM Coding Style (Two-Always Block)

 Block 1: State Register (Sequential)

 Stores present state
 Triggered on clock
 Uses non-blocking assignment

```verilog
always @(posedge clk or posedge rst) begin
    if (rst)
        state <= IDLE;
    else
        state <= next_state;
end
```

---

 Block 2: Next State Logic (Combinational)

 Determines next state
 Uses blocking assignment
 Must include default

```verilog
always @(*) begin
    next_state = IDLE;
    case (state)
        IDLE: if (in) next_state = S1;
        S1  : if (!in) next_state = S2;
        default: next_state = IDLE;
    endcase
end
```

---

 7. Output Logic Methods

 Method 1: Inside combinational block

```verilog
always @(*) begin
    out = 0;
    case (state)
        S2: out = 1;
    endcase
end
```

---

 Method 2: Continuous assignment

```verilog
assign out = (state == DONE);
```

---

 Method 3: Registered output (best practice)

```verilog
always @(posedge clk) begin
    out <= (state == DONE);
end
```

✔ Removes glitches
✔ Better timing

---

 8. Example: Moore FSM – Sequence Detector (1011)

 States:

IDLE → S1 → S10 → S101 → S1011

Output = 1 when in S1011

---

 Verilog Code

```verilog
module seq_1011 (
    input clk, rst, in,
    output reg out
);

    typedef enum reg [2:0] {
        IDLE  = 3'b000,
        S1    = 3'b001,
        S10   = 3'b010,
        S101  = 3'b011,
        S1011 = 3'b100
    } state_t;

    state_t state, next_state;

    // State register
    always @(posedge clk or posedge rst) begin
        if (rst)
            state <= IDLE;
        else
            state <= next_state;
    end

    // Next state logic
    always @(*) begin
        next_state = IDLE;
        case (state)
            IDLE : if (in) next_state = S1;
            S1   : if (!in) next_state = S10;
            S10  : if (in) next_state = S101;
            S101 : if (in) next_state = S1011;
            S1011: next_state = IDLE;
            default: next_state = IDLE;
        endcase
    end

    // Output logic
    always @(*) begin
        out = (state == S1011);
    end

endmodule
```

---

 9. Hardware View of FSM

FSM synthesizes into:

 Flip-flops → store state
 Combinational logic → compute next state
 Optional registers → outputs

FSM acts as controller
Datapath acts as worker

---

 10. Common Design Mistakes

❌ No default state
❌ Blocking assignment in sequential block
❌ Missing reset
❌ Missing default case
❌ Mixing logic
❌ No testbench
❌ Unhandled illegal states

---

 11. Testbench Strategy

Testbench should:

 Generate clock
 Apply reset
 Change inputs
 Observe output

```verilog
always 5 clk = ~clk;

initial begin
    rst = 1; in = 0;
    10 rst = 0;

    in = 1; 10;
    in = 0; 10;
    in = 1; 10;
    in = 1; 10;

    $finish;
end
```

---

 12. Applications of FSM

 Traffic light controller
 Sequence detector
 Elevator controller
 CPU control unit
 UART controller
 Washing machine
 Protocol handler

---

 Summary

Finite State Machines:

 Model sequential behavior
 Provide structure
 Improve reliability
 Simplify control logic

In Verilog:

 Use two always blocks
 Use correct assignments
 Always reset
 Always define defaults

FSM = Backbone of control logic
